<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego del Gato Saltarín - Gato Animado Realista</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #gameCanvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="300"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const cat = {
            x: 50,
            y: 200,
            width: 60,
            height: 40,
            jumping: false,
            yVelocity: 0,
            xVelocity: 0,
            gravity: 0.8,
            jumpStrength: -15,
            speed: 5,
            frame: 0,
            frameCount: 4,
            frameTick: 0,
            frameInterval: 5
        };

        const obstacles = [];
        let score = 0;
        let gameSpeed = 5;

        // Crear hoja de sprites del gato
        const catSprite = document.createElement('canvas');
        catSprite.width = cat.width * cat.frameCount;
        catSprite.height = cat.height;
        const catCtx = catSprite.getContext('2d');

        function createCatSprite() {
            const colors = ['#FFA500', '#FFD700', '#FF8C00', '#FFA07A']; // Diferentes tonos de naranja
            for (let i = 0; i < cat.frameCount; i++) {
                // Cuerpo principal
                catCtx.fillStyle = colors[i];
                catCtx.beginPath();
                catCtx.ellipse(cat.width * i + 30, 25, 25, 15, 0, 0, 2 * Math.PI);
                catCtx.fill();

                // Cabeza
                catCtx.beginPath();
                catCtx.ellipse(cat.width * i + 45, 15, 12, 10, 0, 0, 2 * Math.PI);
                catCtx.fill();

                // Orejas
                catCtx.beginPath();
                catCtx.moveTo(cat.width * i + 38, 8);
                catCtx.lineTo(cat.width * i + 42, 2);
                catCtx.lineTo(cat.width * i + 46, 8);
                catCtx.fill();

                catCtx.beginPath();
                catCtx.moveTo(cat.width * i + 52, 8);
                catCtx.lineTo(cat.width * i + 56, 2);
                catCtx.lineTo(cat.width * i + 60, 8);
                catCtx.fill();

                // Ojos
                catCtx.fillStyle = 'green';
                catCtx.beginPath();
                catCtx.ellipse(cat.width * i + 42, 13, 2, 3, 0, 0, 2 * Math.PI);
                catCtx.fill();
                catCtx.beginPath();
                catCtx.ellipse(cat.width * i + 52, 13, 2, 3, 0, 0, 2 * Math.PI);
                catCtx.fill();

                // Patas (posición variable según el frame)
                catCtx.fillStyle = colors[i];
                catCtx.fillRect(cat.width * i + 10, 35 + (i % 2) * 3, 5, 5);
                catCtx.fillRect(cat.width * i + 20, 35 + ((i + 1) % 2) * 3, 5, 5);
                catCtx.fillRect(cat.width * i + 40, 35 + (i % 2) * 3, 5, 5);
                catCtx.fillRect(cat.width * i + 50, 35 + ((i + 1) % 2) * 3, 5, 5);

                // Cola (posición variable según el frame)
                catCtx.beginPath();
                catCtx.moveTo(cat.width * i + 5, 25);
                catCtx.quadraticCurveTo(cat.width * i, 20 + (i % 2) * 10, cat.width * i + 5, 15 + (i % 2) * 5);
                catCtx.stroke();
            }
        }

        createCatSprite();

        function drawCat() {
            ctx.drawImage(
                catSprite,
                cat.frame * cat.width, 0, cat.width, cat.height,
                cat.x, cat.y, cat.width, cat.height
            );

            // Actualizar frame para animación
            cat.frameTick++;
            if (cat.frameTick >= cat.frameInterval) {
                cat.frame = (cat.frame + 1) % cat.frameCount;
                cat.frameTick = 0;
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = 'brown';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
        }

        function drawBackground() {
            // Cielo
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Suelo
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 240, canvas.width, 60);

            // Detalles del suelo
            ctx.fillStyle = '#1E8449';
            for (let i = 0; i < canvas.width; i += 30) {
                ctx.beginPath();
                ctx.moveTo(i, 240);
                ctx.lineTo(i + 15, 250);
                ctx.lineTo(i + 30, 240);
                ctx.fill();
            }
        }

        function jump() {
            if (!cat.jumping) {
                cat.jumping = true;
                cat.yVelocity = cat.jumpStrength;
            }
        }

        function updateCatPosition() {
            cat.x += cat.xVelocity;
            cat.y += cat.yVelocity;
            cat.yVelocity += cat.gravity;

            if (cat.x < 0) cat.x = 0;
            if (cat.x + cat.width > canvas.width) cat.x = canvas.width - cat.width;

            if (cat.y > 200) {
                cat.y = 200;
                cat.jumping = false;
                cat.yVelocity = 0;
            }
        }

        function checkCollision(obstacle) {
            return cat.x < obstacle.x + obstacle.width &&
                   cat.x + cat.width > obstacle.x &&
                   cat.y < obstacle.y + obstacle.height &&
                   cat.y + cat.height > obstacle.y;
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            drawCat();
            drawObstacles();
            
            updateCatPosition();
            
            obstacles.forEach((obstacle, index) => {
                obstacle.x -= gameSpeed;
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1);
                    score++;
                }
                if (checkCollision(obstacle)) {
                    alert(`¡Juego terminado! Puntuación: ${score}`);
                    score = 0;
                    obstacles.length = 0;
                    gameSpeed = 5;
                    cat.x = 50;
                }
            });
            
            if (Math.random() < 0.02) {
                obstacles.push({
                    x: canvas.width,
                    y: 200,
                    width: 20,
                    height: 40
                });
            }
            
            gameSpeed += 0.001;
            
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Puntuación: ${score}`, 650, 30);
            
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowUp':
                    jump();
                    break;
                case 'ArrowLeft':
                    cat.xVelocity = -cat.speed;
                    break;
                case 'ArrowRight':
                    cat.xVelocity = cat.speed;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                case 'ArrowRight':
                    cat.xVelocity = 0;
                    break;
            }
        });

        gameLoop();
    </script>
</body>
</html>